<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>全局错误处理和日志的简单使用</title>
      <link href="/2024/05/15/errhandler/"/>
      <url>/2024/05/15/errhandler/</url>
      
        <content type="html"><![CDATA[<p>因为，前端总是因为各种稀奇原因报服务错误，而gin本身的日志信息及其简洁，因此<del>老登</del>部长让我写一个日志系统，在写日志系统前，应该先了解一下全局错误处理，这样可方便我们对错误信息进行处理，以便形成一个日志。</p><h3 id="全局错误处理"><a href="#全局错误处理" class="headerlink" title="全局错误处理"></a>全局错误处理</h3><p>在 golang 开发中我们经常会使用 gin 作为 web 框架，gin 一直以高性能和简单著称，但gin 的错误处理却不太尽人意。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>首先，我们要明白一点，为什么要进行全局的错误管理，有以下几点原因。</p><ol><li>一致性：全局错误管理确保无论在应用的哪个部分发生错误，都能以一致的方式进行处理和响应，避免了不同部分使用不同的错误处理策略。</li><li>可维护性：集中式的错误处理使得错误处理逻辑更加集中，便于维护和更新。</li><li>简洁性：通过全局错误管理，可以避免错误处理逻辑在每个路由或服务中重复编写。</li><li>容错性：全局错误管理有助于构建更加健壮的应用，即使在出现错误的情况下，应用也能继续运行而不是崩溃。</li><li>日志记录：全局错误管理通常包括详细的错误日志记录，这对于分析错误原因和进行后续的优化非常重要。</li></ol><h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>在了解了上述这些原因后，我们可以开始上手。</p><p><del>众所周知</del>，在Gin框架中，gin.HandlerFunc是一个类型别名，代表了一个处理HTTP请求的函数。这个函数接收一个*gin.Context作为参数，这个上下文对象包含了HTTP请求和响应的所有信息，以及处理请求所需的各种方法。</p><p>具体来说，gin.HandlerFunc的定义如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type HandlerFunc func(*Context)</span><br></pre></td></tr></tbody></table></figure><p>这里的Context是Gin框架中的核心类型，它是一个结构体，包含了HTTP请求的相关信息（如请求头、查询参数、请求体等）以及响应的方法（如设置响应状态码、发送响应体等）。<br>在Gin中，你可以为每个路由定义一个或多个处理函数，这些函数就是HandlerFunc类型的。当HTTP请求到达对应的路由时，Gin会调用这些处理函数来处理请求。</p><p>所以我们可以通过调整gin.HandlerFunc来对每个请求产生的错误进行处理，但从定义上看，HandlerFunc是没有返回值的</p><p>带着这个思考我们定义一个type</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type HandlerFunc func(c *gin.Context) error</span><br></pre></td></tr></tbody></table></figure><p>这样一来我们的HandlerFunc就变成一个有返回值的函数，那么有什么办法让gin的HandlerFunc支持我们定义的这个函数格式呢？这时候我们想到了在golang里面函数是一等公民，我们可以把函数作为参数或者返回值。我们试着把这个定义好HandlerFunc作为一个参数传进函数返回一个gin支持的HandlerFunc。下面我们来尝试一下。代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func ErrHandler() gin.HandlerFunc {</span><br><span class="line">return func(c *gin.Context) {</span><br><span class="line">c.Next()</span><br><span class="line">if length := len(c.Errors); length &gt; 0 {</span><br><span class="line">e := c.Errors[length-1]</span><br><span class="line">err := e.Err</span><br><span class="line">if err != nil {</span><br><span class="line">// TODO 建立日志系统</span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如此，我们就能通过c.Error(),把报错信息传给这个中间件，然后在这个中间件统一处理。</p><h3 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h3><p>既然实现了错误的全局管理，所以是不是我们可以进一步实现自定义错误，使得后端服务报错返回给前端的错误信息在一块处理，而不是每个接口都要写。</p><p>如此便是微精弘的代码处理了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func ErrHandler() gin.HandlerFunc {</span><br><span class="line">return func(c *gin.Context) {</span><br><span class="line">c.Next()</span><br><span class="line">fmt.Println(c.Errors)</span><br><span class="line">if length := len(c.Errors); length &gt; 0 {</span><br><span class="line">e := c.Errors[length-1]</span><br><span class="line">err := e.Err</span><br><span class="line">if err != nil {</span><br><span class="line">var Err *apiException.Error</span><br><span class="line">if e, ok := err.(*apiException.Error); ok {</span><br><span class="line">Err = e</span><br><span class="line">} else if e, ok := err.(error); ok {</span><br><span class="line">Err = apiException.OtherError(e.Error())</span><br><span class="line">} else {</span><br><span class="line">Err = apiException.ServerError</span><br><span class="line">}</span><br><span class="line">// TODO 建立日志系统</span><br><span class="line"></span><br><span class="line">c.JSON(Err.StatusCode, Err)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">微精弘的这个中间件是吧错误信息也在中间件返回给前端了。</span><br></pre></td></tr></tbody></table></figure><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>但是如果我们要设置日志的话，那微精弘的这个缺会丢失掉最初的报错信息了（可能理解有误），所以我中间件是专门处理原始的错误信息记录，返回给前端就在utils的JsonResponse统一处理掉成功信息和自定义错误了。</p><p>然后再学长的推荐下，我使用的是zap的第三方日志库。</p><p>Zap 是 Uber 开源的高性能日志库，专为 Go 语言设计。以下是 Zap 的一些主要优点：</p><ol><li>高性能：Zap 通过避免使用 interface{} 带来的开销、减少内存分配和垃圾收集（GC）的压力，实现了高性能日志记录。</li><li>零内存分配：Zap 在某些关键路径上实现了零内存分配技术，进一步提高了性能。</li><li>结构化日志：Zap 支持记录结构化日志，可以直接将结构体、map、slice 等复杂类型作为日志字段，方便日志的后续处理和分析。</li><li>多种日志级别：Zap 提供了多种日志级别，如 debug、info、warn、error 等，方便开发者根据不同情况记录不同级别的日志。</li><li>灵活的配置：Zap 提供了灵活的配置选项，允许开发者自定义日志输出格式、输出目标等。</li><li>内置的 Encoder：Zap 内置了 ConsoleEncoder 和 JSONEncoder 两种编码器，分别适用于人类阅读和机器处理的场景。</li><li>对象池：Zap 使用 sync.Pool 来减少内存分配，通过对象复用来降低 GC 压力。</li><li>并发安全：Zap 的设计考虑到了并发控制，通过写时复制机制等策略有效避免了竞态条件。</li><li>社区支持：作为一个开源项目，Zap 拥有活跃的社区支持，保证了其持续的维护和更新。</li></ol><p>因此日志的实现效果如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">func ErrHandler() gin.HandlerFunc {</span><br><span class="line">logFilePath := "app.log"</span><br><span class="line"></span><br><span class="line">// 检查日志文件是否存在</span><br><span class="line">if _, err := os.Stat(logFilePath); os.IsNotExist(err) {</span><br><span class="line">// 如果日志文件不存在，则创建新的日志文件</span><br><span class="line">_, err := os.Create(logFilePath)</span><br><span class="line">if err != nil {</span><br><span class="line">// 创建日志文件失败，记录错误并返回空的中间件处理函数</span><br><span class="line">zap.S().Error("Failed to create log file:", err)</span><br><span class="line">return func(c *gin.Context) {}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 打开日志文件</span><br><span class="line">logFile, err := os.OpenFile(logFilePath, os.O_APPEND|os.O_WRONLY, os.ModeAppend)</span><br><span class="line">if err != nil {</span><br><span class="line">// 打开日志文件失败，记录错误并返回空的中间件处理函数</span><br><span class="line">zap.S().Error("Failed to open log file:", err)</span><br><span class="line">return func(c *gin.Context) {}</span><br><span class="line">}</span><br><span class="line">writeSyncer := zapcore.AddSync(logFile)</span><br><span class="line">encoderConfig := zap.NewProductionEncoderConfig()</span><br><span class="line">encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder</span><br><span class="line">encoder := zapcore.NewJSONEncoder(encoderConfig)</span><br><span class="line">core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel)</span><br><span class="line"></span><br><span class="line">logger := zap.New(core, zap.AddCaller())</span><br><span class="line">defer logger.Sync()</span><br><span class="line"></span><br><span class="line">return func(c *gin.Context) {</span><br><span class="line">c.Next()</span><br><span class="line">if length := len(c.Errors); length &gt; 0 {</span><br><span class="line">e := c.Errors[length-1]</span><br><span class="line">err := e.Err</span><br><span class="line">if err != nil {</span><br><span class="line">// TODO 建立日志系统</span><br><span class="line">logger.Error("Request error",</span><br><span class="line">                    zap.String("path", c.Request.URL.Path),</span><br><span class="line">                    zap.String("method", c.Request.Method),</span><br><span class="line">                    zap.Int("status", Err.StatusCode),</span><br><span class="line">                    zap.Error(err)</span><br><span class="line">                )</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如此，我们便实现了全局错误的日志记录。</p><h3 id="日志分级"><a href="#日志分级" class="headerlink" title="日志分级"></a>日志分级</h3><p>但是，我们又遇到了一个问题，就是zap的功能强大有一点事它支持多种日志级别，而我们现在这个是只有error一种级别，所以我们要让这个中间件可以识别不同的错误类型然后进行不同级别的日志处理。<br>我在看到c.Error()返回的是*gin.Error，也就是上面代码中的e，而它的定义是</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Error struct {</span><br><span class="line">    Err  error</span><br><span class="line">    Type ErrorType</span><br><span class="line">    Meta any</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以我发现了这个错误定义其实是有错误类型的，所以我们只要根据这个类型设置并处理就可以实现我们的结果。<br>将</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logger.Error("Request error",</span><br><span class="line">    zap.String("path", c.Request.URL.Path),</span><br><span class="line">    zap.String("method", c.Request.Method),</span><br><span class="line">    zap.Int("status", Err.StatusCode),</span><br><span class="line">    zap.Error(err)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>变成</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var logLevel zapcore.Level</span><br><span class="line">switch e.Type {</span><br><span class="line">case gin.ErrorTypePublic:</span><br><span class="line">logLevel = zapcore.ErrorLevel</span><br><span class="line">case gin.ErrorTypeBind:</span><br><span class="line">    logLevel = zapcore.WarnLevel</span><br><span class="line">case gin.ErrorTypePrivate:</span><br><span class="line">logLevel = zapcore.DebugLevel</span><br><span class="line">default:</span><br><span class="line">logLevel = zapcore.InfoLevel</span><br><span class="line">}</span><br><span class="line">logger.Check(logLevel, "Error reported").Write(</span><br><span class="line">zap.String("path", c.Request.URL.Path),</span><br><span class="line">zap.String("method", c.Request.Method),</span><br><span class="line">zap.Error(err),</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>所以我们传来错误的时候也要进行处理一下,变成以下这样</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Error(gin.Error{Err: err, Type: gin.ErrorTypeBind}) //c.Error()传输的Type默认是ErrorTypePrivate</span><br></pre></td></tr></tbody></table></figure><p>然后，运行一下看看结果，发现失败了，什么原因呢，好像只把Err的副本传过去了，所以我们改成引用试试。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Error(&amp;gin.Error{Err: err, Type: gin.ErrorTypeBind})</span><br></pre></td></tr></tbody></table></figure><p>最后不出所料的成功了。</p><p><del>因为日志分级和日志自定义还没有什么具体的实现场景，先这样了。</del></p><h3 id="panic异常处理"><a href="#panic异常处理" class="headerlink" title="panic异常处理"></a>panic异常处理</h3><p>有时候我们还会遇到比如数组越界，数据库异常时产生panic报错，但我们肯定不能直接让服务崩掉，所以也可以在这个中间件用recover()处理并用日志记录下来。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">defer func() {</span><br><span class="line">if r := recover(); r != nil {</span><br><span class="line">// Handle panic and log the error</span><br><span class="line">stack := debug.Stack()</span><br><span class="line">logger.Error("Panic recovered",</span><br><span class="line">zap.String("path", c.Request.URL.Path),</span><br><span class="line">zap.String("method", c.Request.Method),</span><br><span class="line">zap.Any("panic", r),</span><br><span class="line">zap.ByteString("stacktrace", stack),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusInternalServerError, gin.H{</span><br><span class="line">"code":  http.StatusInternalServerError,</span><br><span class="line">"msg": apiException.ServerError.Msg,</span><br><span class="line">})</span><br><span class="line">c.Abort()</span><br><span class="line">}</span><br><span class="line">}()</span><br></pre></td></tr></tbody></table></figure><p>综上，我们实现了一个Panic捕获和全局错误日志记录的中间件，完整代码如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">func ErrHandler() gin.HandlerFunc {</span><br><span class="line">logFilePath := "app.log"</span><br><span class="line"></span><br><span class="line">// 检查日志文件是否存在</span><br><span class="line">if _, err := os.Stat(logFilePath); os.IsNotExist(err) {</span><br><span class="line">// 如果日志文件不存在，则创建新的日志文件</span><br><span class="line">_, err := os.Create(logFilePath)</span><br><span class="line">if err != nil {</span><br><span class="line">// 创建日志文件失败，记录错误并返回空的中间件处理函数</span><br><span class="line">zap.S().Error("Failed to create log file:", err)</span><br><span class="line">return func(c *gin.Context) {}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 打开日志文件</span><br><span class="line">logFile, err := os.OpenFile(logFilePath, os.O_APPEND|os.O_WRONLY, os.ModeAppend)</span><br><span class="line">if err != nil {</span><br><span class="line">// 打开日志文件失败，记录错误并返回空的中间件处理函数</span><br><span class="line">zap.S().Error("Failed to open log file:", err)</span><br><span class="line">return func(c *gin.Context) {}</span><br><span class="line">}</span><br><span class="line">writeSyncer := zapcore.AddSync(logFile)</span><br><span class="line">encoderConfig := zap.NewProductionEncoderConfig()</span><br><span class="line">encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder</span><br><span class="line">encoder := zapcore.NewJSONEncoder(encoderConfig)</span><br><span class="line">core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel)</span><br><span class="line"></span><br><span class="line">logger := zap.New(core, zap.AddCaller())</span><br><span class="line">defer logger.Sync()</span><br><span class="line"></span><br><span class="line">return func(c *gin.Context) {</span><br><span class="line">defer func() {</span><br><span class="line">if r := recover(); r != nil {</span><br><span class="line">// Handle panic and log the error</span><br><span class="line">stack := debug.Stack()</span><br><span class="line">logger.Error("Panic recovered",</span><br><span class="line">zap.String("path", c.Request.URL.Path),</span><br><span class="line">zap.String("method", c.Request.Method),</span><br><span class="line">zap.Any("panic", r),</span><br><span class="line">zap.ByteString("stacktrace", stack),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusInternalServerError, gin.H{</span><br><span class="line">"code":  http.StatusInternalServerError,</span><br><span class="line">"msg": apiException.ServerError.Msg,</span><br><span class="line">})</span><br><span class="line">c.Abort()</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">c.Next()</span><br><span class="line">if length := len(c.Errors); length &gt; 0 {</span><br><span class="line">e := c.Errors[length-1]</span><br><span class="line">err := e.Err</span><br><span class="line">if err != nil {</span><br><span class="line">// TODO 建立日志系统</span><br><span class="line">var logLevel zapcore.Level</span><br><span class="line">switch e.Type {</span><br><span class="line">case gin.ErrorTypePublic:</span><br><span class="line">logLevel = zapcore.ErrorLevel</span><br><span class="line">case gin.ErrorTypeBind:</span><br><span class="line">logLevel = zapcore.WarnLevel</span><br><span class="line">case gin.ErrorTypePrivate:</span><br><span class="line">logLevel = zapcore.DebugLevel</span><br><span class="line">default:</span><br><span class="line">logLevel = zapcore.InfoLevel</span><br><span class="line">}</span><br><span class="line">logger.Check(logLevel, "Error reported").Write(</span><br><span class="line">zap.String("path", c.Request.URL.Path),</span><br><span class="line">zap.String("method", c.Request.Method),</span><br><span class="line">zap.Error(err),</span><br><span class="line">)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go的标准项目布局</title>
      <link href="/2024/05/12/project-directory/"/>
      <url>/2024/05/12/project-directory/</url>
      
        <content type="html"><![CDATA[<p>因为笔者一开始是在精弘暑期课入门的go，因此主要学习的还是部门项目微精弘的代码目录结构，所以对go的标准目录结构不是很了解，特此出一篇文章来捋一下go现在比较规范的目录结构，以此来学习。</p><h3 id="目录规范"><a href="#目录规范" class="headerlink" title="目录规范"></a>目录规范</h3><p>虽然每个项目的目录结构并不是有规定模板的，也有很多优秀的项目并不是常规的项目布局，还是要依据项目类型、大小及灵活程度做调整，但一定要保证结构清晰！<br>一般要求：</p><ul><li>命名清晰：目录命名要清晰、简介，不宜过长或过短。目录名要求能清晰表达出该目录所要实现的功能，在清晰表达的基础上最好用单数，避免单复混用的情况。</li><li>功能明确：一个目录所要实现的功能应该是明确的、并且在整个项目目录中具有高辨识度。</li><li>全面性：目录结构应该尽可能全面地包含研发过程中需要的功能，例如文档、脚本、源码管理、API 实现、工具包、第三方包、测试、编译产物等。</li><li>可预测性：项目规模一般是从小到大的，所以一个好的目录结构应该能够在项目变大时，仍然保持之前的目录结构。</li><li>可扩展性：每个目录下存放了同类的功能，在项目变大时，这些目录应该可以存放更多同类功能</li></ul><h3 id="目录类型"><a href="#目录类型" class="headerlink" title="目录类型"></a>目录类型</h3><p>根据项目的功能，目录结构可以分为两种：</p><ul><li>平铺式目录结构</li><li>结构化目录结构</li></ul><h3 id="平铺式目录结构"><a href="#平铺式目录结构" class="headerlink" title="平铺式目录结构"></a>平铺式目录结构</h3><p>当一个项目是体量较小或是一个工具库时，适合使用平铺式目录结构。项目的代码都存放在项目的根目录下，可以减少项目引用路径的长度。例如 github.com/golang/glog：</p><h3 id="结构化目录结构"><a href="#结构化目录结构" class="headerlink" title="结构化目录结构"></a>结构化目录结构</h3><p>当前 Go 社区比较推荐的结构化目录结构是 <a href="https://github.com/golang-standards/project-layout/blob/master/README_zh.md">project-layout</a> 。虽然它并不是官方和社区的规范，但因为组织方式比较合理，被很多 Go 开发人员接受并推荐，因此我现在先以这个作为规范。</p><h4 id="微精弘目录架构"><a href="#微精弘目录架构" class="headerlink" title="微精弘目录架构"></a>微精弘目录架构</h4><p>在讲这个新的目录结构前，我先来聊聊wjh的目录结构</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── app </span><br><span class="line">│&nbsp;&nbsp; ├── apiException           //定义统一的错误码</span><br><span class="line">│&nbsp;&nbsp; ├── config                 //从数据库获取配置信息</span><br><span class="line">│&nbsp;&nbsp; ├── controllers            // 控制器，主要包括了处理函数</span><br><span class="line">│&nbsp;&nbsp; ├── midwares               // 中间件</span><br><span class="line">│&nbsp;&nbsp; ├── models                 // 模型</span><br><span class="line">│&nbsp;&nbsp; ├── services               // 业务逻辑，与数据库进行交互</span><br><span class="line">│&nbsp;&nbsp; └── utils                  // 一些封装好的工具</span><br><span class="line">├── config                     // </span><br><span class="line">│&nbsp;&nbsp; ├── api                    //一些api常量的定义</span><br><span class="line">│&nbsp;&nbsp; ├── config                 //对viper的初始化</span><br><span class="line">│&nbsp;&nbsp; ├── database               //对数据库（如mysql或mongodb）的初始化和自动建</span><br><span class="line">│&nbsp;&nbsp; ├── router                 //路由的定义</span><br><span class="line">│&nbsp;&nbsp; ├── redis                  //redis的配置和初始化</span><br><span class="line">│&nbsp;&nbsp; ├── session                //session的配置和初始化</span><br><span class="line">│&nbsp;&nbsp; └── wechat                 //微信配置和初始化</span><br><span class="line">├── dockerfile                 //docker制作文件</span><br><span class="line">├── docker-compose.yml         //Docker Compose 工具使用的配置文件</span><br><span class="line">├── go.mod                     //用于管理项目的依赖关系</span><br><span class="line">├── go.sum                     //为了确保在构建项目时，使用的确切依赖项版本与最初确定的版本相匹配</span><br><span class="line">├── main.go                    //主入口文件</span><br><span class="line">├── Makefile                   //如何构建和编译项目的文本工具</span><br></pre></td></tr></tbody></table></figure><p>yysy，这个目录结构还是比较简单且清晰的，易于新手理解</p><h4 id="project-layout目录架构"><a href="#project-layout目录架构" class="headerlink" title="project-layout目录架构"></a>project-layout目录架构</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">project-layout/</span><br><span class="line">├── api                       # 存放 API 定义文件，如 OpenAPI/Swagger 规范或 gRPC 服务定义</span><br><span class="line">├── cmd                       # 包含应用程序的入口点，每个应用程序的可执行文件的 main 包</span><br><span class="line">├── chart                     # Helm Chart 文件夹，用于 Kubernetes 部署（如果使用 Helm）</span><br><span class="line">├── conf                      # 存放配置文件，如 YAML、JSON 格式的配置</span><br><span class="line">├── docs                      # 项目文档，可能包括 API 文档、开发者指南等</span><br><span class="line">│   ├── dev                   # 开发者文档</span><br><span class="line">│   │   ├── en-US             # 英文文档</span><br><span class="line">│   │   └── zh-CN             # 中文文档</span><br><span class="line">│   ├── guide                 # 用户指南或教程</span><br><span class="line">│   │   ├── en-US             # 英文指南</span><br><span class="line">│   │   └── zh-CN             # 中文指南</span><br><span class="line">│   └── README.md             # 项目 README 文档</span><br><span class="line">├── examples                  # 项目使用示例，可能包括代码片段或完整的示例应用程序</span><br><span class="line">├── go.mod                    # Go Modules 模块依赖文件</span><br><span class="line">├── go.sum                    # Go Modules 模块依赖的校验和</span><br><span class="line">├── hack                      # 构建脚本、CI 配置和辅助工具</span><br><span class="line">│   ├── include              # Makefile 片段，被根 Makefile 包含</span><br><span class="line">│   ├── scripts              # 存放用于构建、测试、部署等的 Shell 脚本</span><br><span class="line">│   └── docker                # Docker 相关配置，如 Dockerfile 和 Docker Compose 文件</span><br><span class="line">├── internal                  # 项目内部包，包含服务器、模型、配置等</span><br><span class="line">│   ├── app                   # 应用程序的主体逻辑</span><br><span class="line">│   │   └── server.go        # 服务器初始化和启动</span><br><span class="line">│   ├── global                # 全局可用的配置和初始化代码</span><br><span class="line">│   │   └── config            # 配置加载和解析</span><br><span class="line">│   ├── http                  # HTTP 相关代码</span><br><span class="line">│   │   ├── router            # 路由注册</span><br><span class="line">│   │   ├── middleware        # 中间件逻辑</span><br><span class="line">│   │   ├── dao               # 数据访问对象层</span><br><span class="line">│   │   ├── controllers       # 控制器，处理 HTTP 请求</span><br><span class="line">│   │   └── services          # 业务逻辑服务层</span><br><span class="line">│   ├── models                # 数据模型定义</span><br><span class="line">│   │   ├── user.go           # 用户模型定义</span><br><span class="line">│   │   └── ...</span><br><span class="line">│   └── pkg                  # 内部工具包</span><br><span class="line">│       ├── code.go          # 错误码定义</span><br><span class="line">│       ├── utils             # 内部使用的工具函数</span><br><span class="line">│       ├── log               # 日志配置和管理</span><br><span class="line">│       ├── database          # 数据库连接和初始化</span><br><span class="line">│       ├── session           # 会话管理</span><br><span class="line">│       └── redis             # Redis 配置和管理</span><br><span class="line">├── logs                     # 日志文件输出目录</span><br><span class="line">├── LICENSE                   # 项目许可证文件</span><br><span class="line">├── Makefile                  # 根 Makefile 文件，包含构建和编译项目的指令</span><br><span class="line">├── pkg                       # 可被外部引用的全局工具包</span><br><span class="line">│   └── util                  # 通用工具代码</span><br><span class="line">├── README.md                  # 项目 README 文档，通常提供项目概览和快速开始指南</span><br><span class="line">├── vendor                    # 存放项目依赖包（在使用 Go Modules 之前的做法，现在通常由 go.mod 和 go.sum 管理）</span><br><span class="line">├── deployments               # 部署相关的配置和模板文件，如 Docker、Kubernetes 配置</span><br><span class="line">├── test                      # 测试代码，包括单元测试、集成测试和端到端测试</span><br><span class="line">│   ├── testdata              # 测试数据文件</span><br><span class="line">│   └── e2e                   # 端到端测试代码</span><br><span class="line">├── web                       # 前端资源文件，如 React、Vue 项目生成的静态资源</span><br><span class="line">├── public                    # 公共静态资源，如未构建的前端资源或可直接访问的静态文件</span><br><span class="line">└── .gitignore                # Git 忽略文件配置</span><br></pre></td></tr></tbody></table></figure><p>经过多方参考，最终形成这样的一个目录，好的目录结构，总能让人眼前一亮，舒舒服服的看下去。项目的目录结构并没有一个强制性规范，我们应该不断看优秀的项目的结构目录，不断优化自己的架构意识，使得自己项目的扩展性加大的同时还能保证清晰。加油(ง •_•)ง</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go测试（基于testing基本库）</title>
      <link href="/2024/05/02/go-testing/"/>
      <url>/2024/05/02/go-testing/</url>
      
        <content type="html"><![CDATA[<p>老登让我研究一下后端测试，看看MongoDB读写操作的性能，遂开始研究go的testing基本库</p><p>在testing的测试有这三种类型——单元测试，基准(性能)测试，示例测试</p><table><thead><tr><th>类型</th><th>格式</th><th>作用</th></tr></thead><tbody><tr><td>测试函数</td><td>函数名前缀为Test</td><td>测试程序的一些逻辑行为是否正确</td></tr><tr><td>基准函数</td><td>函数名前缀为Benchmark</td><td>测试函数的性能</td></tr><tr><td>示例函数</td><td>函数名前缀为Example</td><td>为文档提供示例文档</td></tr></tbody></table><p>无论是上面哪一种，都是要依赖go test命令，所有以_test.go为后缀名的源代码文件都是go test测试的一部分，不会被go build编译到最终的可执行文件中。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>先以我这次写的测试为例</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// mongodb.go</span><br><span class="line">type Answer struct {</span><br><span class="line">QuestionID int    `json:"question_id"` //问题ID</span><br><span class="line">SerialNum  int    `json:"serial_num"`  //问题序号</span><br><span class="line">Subject    string `json:"subject"`     //问题</span><br><span class="line">Content    string `json:"content"`     //回答内容</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type AnswerSheet struct {</span><br><span class="line">SurveyID int      `json:"survey_id"` //问卷ID</span><br><span class="line">Time     string   `json:"time"`      //回答时间</span><br><span class="line">Answers  []Answer `json:"answers"`   //回答</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func SaveAnswerSheet(answerSheet AnswerSheet) error {</span><br><span class="line">_, err := database.MDB.InsertOne(context.Background(), answerSheet)</span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line">return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h3><h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p>每个测试函数必须导入testing包，测试函数的基本格式（签名）如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Name为对应的被测试函数</span><br><span class="line">func TestName(t *testing.T){</span><br><span class="line">    // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中参数t用于报告测试失败和附加的日志信息。 testing.T的拥有的方法如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func (c *T) Error(args ...interface{})</span><br><span class="line">func (c *T) Errorf(format string, args ...interface{})</span><br><span class="line">func (c *T) Fail()</span><br><span class="line">func (c *T) FailNow()</span><br><span class="line">func (c *T) Failed() bool</span><br><span class="line">func (c *T) Fatal(args ...interface{})</span><br><span class="line">func (c *T) Fatalf(format string, args ...interface{})</span><br><span class="line">func (c *T) Log(args ...interface{})</span><br><span class="line">func (c *T) Logf(format string, args ...interface{})</span><br><span class="line">func (c *T) Name() string</span><br><span class="line">func (t *T) Parallel()</span><br><span class="line">func (t *T) Run(name string, f func(t *T)) bool</span><br><span class="line">func (c *T) Skip(args ...interface{})</span><br><span class="line">func (c *T) SkipNow()</span><br><span class="line">func (c *T) Skipf(format string, args ...interface{})</span><br><span class="line">func (c *T) Skipped() bool</span><br></pre></td></tr></tbody></table></figure><p>那么我们的测试函数则写在mongodb_test.go文件里</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// TestSaveAnswerSheet 函数的单元测试（可支持多个测试用例）</span><br><span class="line">func TestSaveAnswerSheet(t *testing.T) {</span><br><span class="line">tests := []struct {</span><br><span class="line">name        string</span><br><span class="line">answerSheet AnswerSheet</span><br><span class="line">expectError error</span><br><span class="line">}{</span><br><span class="line">{</span><br><span class="line">name: "有效答卷",</span><br><span class="line">answerSheet: AnswerSheet{</span><br><span class="line">SurveyID: 1,</span><br><span class="line">Time:     time.Now().Format("2006-01-02 15:04:05"),</span><br><span class="line">Answers: []Answer{</span><br><span class="line">{QuestionID: 1, SerialNum: 1, Subject: "subject", Content: "content"},</span><br><span class="line">{QuestionID: 2, SerialNum: 2, Subject: "subject", Content: "content"},</span><br><span class="line">},</span><br><span class="line">},</span><br><span class="line">expectError: nil,</span><br><span class="line">},</span><br><span class="line">//这里可以进行添加更多的测试用例</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for _, tt := range tests {</span><br><span class="line">t.Run(tt.name, func(t *testing.T) {</span><br><span class="line">// 初始化 MongoDB</span><br><span class="line">database.MongodbInit()</span><br><span class="line"></span><br><span class="line">// 保存答卷</span><br><span class="line">err := SaveAnswerSheet(tt.answerSheet)</span><br><span class="line"></span><br><span class="line">if (err != nil) != (tt.expectError != nil) {</span><br><span class="line">t.Errorf("Test case %q failed, expected error: %v, got: %v", tt.name, tt.expectError, err)</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a>go test</h4><p>这是go test的运行结果，比较简洁</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Lenovo\Desktop\QA-System\app\services\mongodbService&gt; go test</span><br><span class="line">2024/05/02 13:27:51 Connected to MongoDB</span><br><span class="line">PASS</span><br><span class="line">ok      QA-System/app/services/mongodbService   0.613s</span><br></pre></td></tr></tbody></table></figure><h4 id="go-test-v"><a href="#go-test-v" class="headerlink" title="go test -v"></a>go test -v</h4><p>所以我们可以试试加上-v的参数,查看测试函数名称和运行时间</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Lenovo\Desktop\QA-System\app\services\mongodbService&gt; go test -v</span><br><span class="line">=== RUN   TestSaveAnswerSheet</span><br><span class="line">2024/05/02 13:29:23 Connected to MongoDB</span><br><span class="line">--- PASS: TestSaveAnswerSheet (0.27s)</span><br><span class="line">PASS</span><br><span class="line">ok      QA-System/app/services/mongodbService   0.547s</span><br></pre></td></tr></tbody></table></figure><h4 id="go-test-run"><a href="#go-test-run" class="headerlink" title="go test -run"></a>go test -run</h4><p>我们还可以添加-run参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被go test命令执行，这里就不做展示了。</p><h4 id="go-test-cover"><a href="#go-test-cover" class="headerlink" title="go test -cover"></a>go test -cover</h4><p>测试覆盖率是你的代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。</p><p>Go提供内置功能来检查你的代码覆盖率。我们可以使用go test -cover来查看测试覆盖率。例如(哎呀，这占比真低)：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Lenovo\Desktop\QA-System\app\services\mongodbService&gt; go test -cover</span><br><span class="line">2024/05/02 13:38:24 Connected to MongoDB</span><br><span class="line">PASS</span><br><span class="line">coverage: 9.4% of statements</span><br><span class="line">ok      QA-System/app/services/mongodbService   0.639s</span><br></pre></td></tr></tbody></table></figure><h3 id="基准函数"><a href="#基准函数" class="headerlink" title="基准函数"></a>基准函数</h3><p>基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkName(b *testing.B){</span><br><span class="line">    // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>基准测试以Benchmark为前缀，需要一个*testing.B类型的参数b，基准测试必须要执行b.N次，这样的测试才有对照性，b.N的值是系统根据实际情况去调整的，从而保证测试的稳定性。 testing.B拥有的方法如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func (c *B) Error(args ...interface{})</span><br><span class="line">func (c *B) Errorf(format string, args ...interface{})</span><br><span class="line">func (c *B) Fail()</span><br><span class="line">func (c *B) FailNow()</span><br><span class="line">func (c *B) Failed() bool</span><br><span class="line">func (c *B) Fatal(args ...interface{})</span><br><span class="line">func (c *B) Fatalf(format string, args ...interface{})</span><br><span class="line">func (c *B) Log(args ...interface{})</span><br><span class="line">func (c *B) Logf(format string, args ...interface{})</span><br><span class="line">func (c *B) Name() string</span><br><span class="line">func (b *B) ReportAllocs()</span><br><span class="line">func (b *B) ResetTimer()</span><br><span class="line">func (b *B) Run(name string, f func(b *B)) bool</span><br><span class="line">func (b *B) RunParallel(body func(*PB))</span><br><span class="line">func (b *B) SetBytes(n int64)</span><br><span class="line">func (b *B) SetParallelism(p int)</span><br><span class="line">func (c *B) Skip(args ...interface{})</span><br><span class="line">func (c *B) SkipNow()</span><br><span class="line">func (c *B) Skipf(format string, args ...interface{})</span><br><span class="line">func (c *B) Skipped() bool</span><br><span class="line">func (b *B) StartTimer()</span><br><span class="line">func (b *B) StopTimer()</span><br></pre></td></tr></tbody></table></figure><p>我们样例的基准测试函数如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkSaveAnswerSheet(b *testing.B) {</span><br><span class="line">// 初始化 MongoDB</span><br><span class="line">database.MongodbInit()</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; b.N; i++ {</span><br><span class="line">// 创建 AnswerSheet 实例并保存</span><br><span class="line">answerSheet := AnswerSheet{</span><br><span class="line">SurveyID: 1,</span><br><span class="line">Time:     time.Now().Format("2006-01-02 15:04:05"),</span><br><span class="line">Answers: []Answer{</span><br><span class="line">{QuestionID: 1, SerialNum: 1, Subject: "subject", Content: "content"},</span><br><span class="line">{QuestionID: 2, SerialNum: 2, Subject: "subject", Content: "content"},</span><br><span class="line">},</span><br><span class="line">}</span><br><span class="line">if err := SaveAnswerSheet(answerSheet); err != nil {</span><br><span class="line">b.Errorf("SaveAnswerSheet() error = %v", err)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="go-test-bench-SaveAnswerSheet"><a href="#go-test-bench-SaveAnswerSheet" class="headerlink" title="go test -bench=SaveAnswerSheet"></a>go test -bench=SaveAnswerSheet</h4><p>基准测试并不会默认执行，需要增加-bench参数，所以我们通过执行go test -bench=SaveAnswerSheet命令执行基准测试，输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Lenovo\Desktop\QA-System\app\services\mongodbService&gt; go test -bench=SaveAnswerSheet</span><br><span class="line">2024/05/02 14:08:16 Connected to MongoDB</span><br><span class="line">2024/05/02 14:08:16 Connected to MongoDB</span><br><span class="line">2024/05/02 14:08:16 Connected to MongoDB</span><br><span class="line">2024/05/02 14:08:17 Connected to MongoDB</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: QA-System/app/services/mongodbService</span><br><span class="line">cpu: AMD Ryzen 7 4800H with Radeon Graphics</span><br><span class="line">BenchmarkSaveAnswerSheet-16     2024/05/02 14:08:17 Connected to MongoDB</span><br><span class="line">2024/05/02 14:08:17 Connected to MongoDB</span><br><span class="line">2024/05/02 14:08:18 Connected to MongoDB</span><br><span class="line">2024/05/02 14:08:19 Connected to MongoDB</span><br><span class="line">      30          39870327 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      QA-System/app/services/mongodbService   4.328s</span><br></pre></td></tr></tbody></table></figure><p>其中BenchmarkSaveAnswerSheet-16表示对SaveAnswerSheet函数进行基准测试，数字16表示GOMAXPROCS的值，这个对于并发基准测试很重要。30和39870327 ns/op表示每次调用Split函数耗时39870327ns，这个结果是30次调用的平均值。</p><h4 id="go-test-bench-SaveAnswerSheet-benchmem"><a href="#go-test-bench-SaveAnswerSheet-benchmem" class="headerlink" title="go test -bench=SaveAnswerSheet -benchmem"></a>go test -bench=SaveAnswerSheet -benchmem</h4><p>我们还可以为基准测试添加-benchmem参数，来获得内存分配的统计数据。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Lenovo\Desktop\QA-System\app\services\mongodbService&gt; go test -bench=SaveAnswerSheet -benchmem</span><br><span class="line">2024/05/02 14:10:55 Connected to MongoDB</span><br><span class="line">2024/05/02 14:10:55 Connected to MongoDB</span><br><span class="line">2024/05/02 14:10:55 Connected to MongoDB</span><br><span class="line">2024/05/02 14:10:55 Connected to MongoDB</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: QA-System/app/services/mongodbService</span><br><span class="line">cpu: AMD Ryzen 7 4800H with Radeon Graphics</span><br><span class="line">BenchmarkSaveAnswerSheet-16     2024/05/02 14:10:56 Connected to MongoDB</span><br><span class="line">2024/05/02 14:10:56 Connected to MongoDB</span><br><span class="line">2024/05/02 14:10:57 Connected to MongoDB</span><br><span class="line">2024/05/02 14:10:58 Connected to MongoDB</span><br><span class="line">      25          43956060 ns/op           10080 B/op        105 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      QA-System/app/services/mongodbService   4.374s</span><br></pre></td></tr></tbody></table></figure><p>其中，10080 B/op表示每次操作内存分配了10080字节，105 allocs/op则表示每次操作进行了105次内存分配。<br>我们可以根据这些测试结果进一步优化我们代码，通过性能测试，我们可以很直观的看见优化后的变化程度</p><h4 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h4><p>func (b *B) RunParallel(body func(*PB))会以并行的方式执行给定的基准测试。</p><p>RunParallel会创建出多个goroutine，并将b.N分配给这些goroutine执行， 其中goroutine数量的默认值为GOMAXPROCS。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在RunParallel之前调用SetParallelism 。RunParallel通常会与-cpu标志一同使用。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkSaveAnswerSheet(b *testing.B) {</span><br><span class="line">// 初始化 MongoDB</span><br><span class="line">database.MongodbInit()</span><br><span class="line"></span><br><span class="line">// 并行度设置为 10</span><br><span class="line">b.SetParallelism(100)</span><br><span class="line"></span><br><span class="line">// 并发测试</span><br><span class="line">b.RunParallel(func(pb *testing.PB) {</span><br><span class="line">// 每个并发测试独立地运行 b.N 次</span><br><span class="line">for pb.Next() {</span><br><span class="line">// 创建 AnswerSheet 实例并保存</span><br><span class="line">answerSheet := AnswerSheet{</span><br><span class="line">SurveyID: 1,</span><br><span class="line">Time:     time.Now().Format("2006-01-02 15:04:05"),</span><br><span class="line">Answers: []Answer{</span><br><span class="line">{QuestionID: 1, SerialNum: 1, Subject: "subject", Content: "content"},</span><br><span class="line">{QuestionID: 2, SerialNum: 2, Subject: "subject", Content: "content"},</span><br><span class="line">},</span><br><span class="line">}</span><br><span class="line">if err := SaveAnswerSheet(answerSheet); err != nil {</span><br><span class="line">b.Errorf("SaveAnswerSheet() error = %v", err)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>虽然设置了100，其实最大也就16，除此之外还可以通过在测试命令后添加-cpu参数如go test -bench=. -cpu 1来指定使用的CPU数量。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>对于还有性能比较函数等等，这里就不多介绍了（主要我也没用到）</p><h3 id="示例函数"><a href="#示例函数" class="headerlink" title="示例函数"></a>示例函数</h3><p>被go test特殊对待的第三种函数就是示例函数，它们的函数名以Example为前缀。它们既没有参数也没有返回值。标准格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func ExampleName() {</span><br><span class="line">    // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为你的代码编写示例代码有如下三个用处：</p><ol><li><p>示例函数能够作为文档直接使用，例如基于web的godoc中能把示例函数与对应的函数或包相关联。</p></li><li><p>示例函数只要包含了// Output:也是可以通过go test运行的可执行测试。</p></li><li><p>示例函数提供了可以直接运行的示例代码，可以直接在golang.org的godoc文档服务器上使用Go Playground运行示例代码。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func ExampleSaveAnswerSheet() {</span><br><span class="line">// 初始化 MongoDB</span><br><span class="line">database.MongodbInit()</span><br><span class="line"></span><br><span class="line">// 创建 AnswerSheet 实例并保存</span><br><span class="line">answerSheet := AnswerSheet{</span><br><span class="line">SurveyID: 1,</span><br><span class="line">Time:     time.Now().Format("2006-01-02 15:04:05"),</span><br><span class="line">Answers: []Answer{</span><br><span class="line">{QuestionID: 1, SerialNum: 1, Subject: "subject", Content: "content"},</span><br><span class="line">{QuestionID: 2, SerialNum: 2, Subject: "subject", Content: "content"},</span><br><span class="line">},</span><br><span class="line">}</span><br><span class="line">if err := SaveAnswerSheet(answerSheet); err != nil {</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol><p>testing库的基本用法大概就这样。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> testing </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>neo4j安装</title>
      <link href="/2024/04/26/neo4j-install/"/>
      <url>/2024/04/26/neo4j-install/</url>
      
        <content type="html"><![CDATA[<p>首先更新apt</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></tbody></table></figure><p>neo4j需要依赖jdk环境，而且还有版本要求的<br>要求jdk要17版本以上</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openjdk-17-jdk</span><br></pre></td></tr></tbody></table></figure><p>查看是否成功安装</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></tbody></table></figure><p>开始安装neo4j</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://neo4j.com/artifact.php?name=neo4j-community-5.17.0-unix.tar.gz -O neo4j-community-5.17.0-unix.tar.gz</span><br></pre></td></tr></tbody></table></figure><p>解压运行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf neo4j-community-5.17.0-unix.tar.gz</span><br></pre></td></tr></tbody></table></figure><p>到这里就成功安装了,然后就进入工作目录运行,这是后台一直运行的，不需要存为service</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd neo4j-community-5.17.0</span><br><span class="line">sudo ./bin/neo4j start</span><br></pre></td></tr></tbody></table></figure><p>当然，也可以停止</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./bin/neo4j stop</span><br></pre></td></tr></tbody></table></figure><p>远程连接设置，打开配置文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim conf/neo4j.conf</span><br></pre></td></tr></tbody></table></figure><p>修改以下代码为true和监听地址修改</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Bolt connector</span><br><span class="line">server.bolt.enabled=true</span><br><span class="line">server.bolt.tls_level=DISABLED</span><br><span class="line">server.bolt.listen_address=:7687</span><br><span class="line">server.bolt.advertised_address=:7687</span><br><span class="line"></span><br><span class="line"># HTTP Connector. There can be zero or one HTTP connectors.</span><br><span class="line">server.http.enabled=true</span><br><span class="line">server.http.listen_address=:7474</span><br><span class="line">server.http.advertised_address=:7474</span><br><span class="line"></span><br><span class="line">server.default_listen_address=0.0.0.0</span><br></pre></td></tr></tbody></table></figure><p>接着保存退出，重新启动服务<br>cd neo4j-community-5.17.0<br>sudo ./bin/neo4j stop<br>sudo ./bin/neo4j start</p><p>最后再云服务器的安全组开放7474和7687两个端口就可以在外面连接该服务器运行的neo4j的知识图谱网页版了。<br>http://（你的ip）:7474/browser/</p>]]></content>
      
      
      <categories>
          
          <category> 模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb安装</title>
      <link href="/2024/04/26/mongodb-install/"/>
      <url>/2024/04/26/mongodb-install/</url>
      
        <content type="html"><![CDATA[<p>问卷系统要求用MongoDB存放答卷数据，因此我在我云服务器上安装了MongoDB</p><p>这是官方的<a href="https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-ubuntu/#std-label-install-mdb-community-ubuntu">安装教程</a></p><p>下面简单介绍我的安装过程</p><p>我的云服务器系统：ubuntu22.04 LTS</p><p>先运行下面这行代码检查服务器系统是否是ubuntu22.04 LTS或ubuntu20.04 LTS</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/lsb-release</span><br></pre></td></tr></tbody></table></figure><h3 id="导入包管理系统使用的公钥"><a href="#导入包管理系统使用的公钥" class="headerlink" title="导入包管理系统使用的公钥"></a>导入包管理系统使用的公钥</h3><p>从终端安装，gnupg如果curl它们尚不可用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnupg curl</span><br></pre></td></tr></tbody></table></figure><p>要导入 MongoDB 公共 GPG 密钥，请运行以下命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://www.mongodb.org/static/pgp/server-7.0.asc | \</span><br><span class="line">   sudo gpg -o /usr/share/keyrings/mongodb-server-7.0.gpg \</span><br><span class="line">   --dearmor</span><br></pre></td></tr></tbody></table></figure><h3 id="为-MongoDB-创建列表文件"><a href="#为-MongoDB-创建列表文件" class="headerlink" title="为 MongoDB 创建列表文件"></a>为 MongoDB 创建列表文件</h3><p>/etc/apt/sources.list.d/mongodb-org-7.0.list为您的 Ubuntu 版本创建列表文件 。</p><p>22.04</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list</span><br></pre></td></tr></tbody></table></figure><p>20.04</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/7.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list</span><br></pre></td></tr></tbody></table></figure><h3 id="重新加载本地包数据库"><a href="#重新加载本地包数据库" class="headerlink" title="重新加载本地包数据库"></a>重新加载本地包数据库</h3><p>发出以下命令重新加载本地包数据库：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-MongoDB-包"><a href="#安装-MongoDB-包" class="headerlink" title="安装 MongoDB 包"></a>安装 MongoDB 包</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y mongodb-org</span><br></pre></td></tr></tbody></table></figure><p>这样我们就安装好了数据库</p><p>接下来我们检查一下是否安装成功，并启动一下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mongod</span><br></pre></td></tr></tbody></table></figure><p>如果您在启动时收到类似以下内容的错误 mongod：<br>Failed to start mongod.service: Unit mongod.service not found.</p><p>首先运行以下命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></tbody></table></figure><p>验证 MongoDB 是否已成功启动</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status mongod</span><br></pre></td></tr></tbody></table></figure><p>其他操作</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable mongod</span><br><span class="line">sudo systemctl stop mongod</span><br><span class="line">sudo systemctl restart mongod</span><br></pre></td></tr></tbody></table></figure><h3 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h3><p>MongoDB好像是可以直接免用户登录的，我们先设置一个用户供我们外部数据库连接</p><p>先启动打开数据库</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongosh</span><br><span class="line">use admin</span><br></pre></td></tr></tbody></table></figure><p>然后输入,user和pwd可根据自己更改</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//这个可以用例如datagrip去连接</span><br><span class="line">db.createUser(</span><br><span class="line">  {</span><br><span class="line">    user: "admin",</span><br><span class="line">    pwd: "abc123",</span><br><span class="line">    roles: [</span><br><span class="line">      { role: "userAdminAnyDatabase", db: "admin" },</span><br><span class="line">    ]</span><br><span class="line">  }</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果返回结果是 { ok: 1 }，那么表示用户创建成功。这意味着 new_root 用户已经被成功创建，并且被赋予了该用户具有对数据库的读取和修改权限。</p><p>我们可以去查看一下是否创建成功 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.getUsers()</span><br></pre></td></tr></tbody></table></figure><p>然后在QA也是</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//这个用程序去连接</span><br><span class="line">use qa</span><br><span class="line">db.createUser(</span><br><span class="line">  {</span><br><span class="line">    user: "new_root",</span><br><span class="line">    pwd: "abc123",</span><br><span class="line">    roles: [</span><br><span class="line">      { role: "readWrite", db: "QA" }</span><br><span class="line">    ]</span><br><span class="line">  }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到上面出现了new_root这个用户了</p><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><p>MongoDB默认是只能本地连接<br>所以我们要去配置文件更改一下，MongoDB的配置文件存在（ /etc/mongod.conf）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/mongod.conf</span><br></pre></td></tr></tbody></table></figure><p>找到 bindIp 配置项，并将其值改为 0.0.0.0，表示允许来自任何 IP 地址的连接：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bindIp: 0.0.0.0</span><br></pre></td></tr></tbody></table></figure><p>找到security:<br>去除#，并加上</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authorization: enabled</span><br></pre></td></tr></tbody></table></figure><p>保存并关闭文件，然后重新启动 MongoDB 服务：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mongodb</span><br></pre></td></tr></tbody></table></figure><p>最后要记得到云服务器的安全组开放27017端口</p><p>之后进入就要</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongosh -u new_root -p</span><br></pre></td></tr></tbody></table></figure><p>然后输入密码</p><p>以上就可以安装好了</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒软项目总结</title>
      <link href="/2024/03/05/hr-summary/"/>
      <url>/2024/03/05/hr-summary/</url>
      
        <content type="html"><![CDATA[<p>今天中午进行了浙江工业大学的寒假软件大赛的验收答辩，整个过程给人感觉还是比较草率的，但至少在构建的过程中还是学到了不少东西。本次比赛分成三个题目，前两个是奖励综测分，最后一个是奖励米，但最终我们选择了奖励综测分的德育导师双向选择系统。</p><h3 id="下面是我们早c晚a小组完成的成果"><a href="#下面是我们早c晚a小组完成的成果" class="headerlink" title="下面是我们早c晚a小组完成的成果"></a>下面是我们早c晚a小组完成的成果</h3><p><a href="https://github.com/Penryn/SelectionSystem-Back">后端仓库地址</a><br><a href="https://github.com/xixiIBN5100/Mutual_Mentor_Selection_front">前端仓库地址</a><br><a href="https://phlin.love/">项目服务地址</a></p><p>在本项目中我和浅浅＆勿念两个人负责该项目后端，他主要负责学生端和教师端的接口完成，我这边也主要写了用户端、管理端和系统的一些自动操作。</p><h3 id="项目的一些亮点（难点）"><a href="#项目的一些亮点（难点）" class="headerlink" title="项目的一些亮点（难点）"></a>项目的一些亮点（难点）</h3><ul><li><p>上传的头像图片有将其格式转换成jpg形式，以减小其图片内存，避免之前试用期上传头像上传半天的尴尬，当时改了我半天码，都一直没成功</p></li><li><p>将xls文件导入进数据库中，这个其实也不是特别难，主要是学校给的数据（姓名、部门、办公室、电话、邮件地址）不够齐全，导致有两个老师连邮件地址都没有，导致系统读取到这个数据时就以为没有五列数据，然后就超出范围报错。</p></li><li><p>这个系统要实现第一轮选择时间截止要让那些未被选择的学生分配教师，同时教师的学生个数最多6人，且第一轮选择时间是有会被再次更改的，一开始想用go自带的库来解决，发现不太行，然后发现有cron的定时库可以使用，但我一开始的想法是每次重新调节第一轮时间的时候来重新设定定时任务，结果没成功，后面改成了每次系统主进程异步每五分钟定时查询数据库的第一轮时间有没有发生改变，如果发送变化再重新设定时间，但感觉这样会不够准时，但这也是没有办法的办法了。后面青鸟学长说可以试试timing的库，然后也有个人好像和我说可以试试信息队列(？忘了，不知道是不是这个了)。</p><h3 id="项目可以改进的地方"><a href="#项目可以改进的地方" class="headerlink" title="项目可以改进的地方"></a>项目可以改进的地方</h3></li><li><p>首先项目有个聊天室，我这里是采用轮询的形式进行较为实时的聊天对话，但事实上可以去尝试一下websocket的方式，这是真·实时对话的正确选择，这学期一定得去实现出来。</p></li><li><p>在这次答辩中，我想给那个老师展示一下我们数据库是有对敏感数据进行加密的，结果那个老师指出我的数据库对所有用户的加密方式是相同无差别，而且他们默认数据因为是一样，所以加密的密文也相同，就是可以通过某个人的信息，从而知道其他人的信息（但是怎么说呢，你得先知道某个人的信息，然后又知道我数据库里其他用户密文和他的密文相同，基本这种情况的出现就是我数据库被黑了），当然，处理这样的方法也有，就是还有个加密方法————加盐加密（bcrypt），我记得我试用期好像是这个方法，这样就可以实现相同文字形成不同的密文。</p></li><li><p>那个老师还提到了每个用户初次登录要去强制设置一个让用户修改密码。(虽然感觉必要性不大，一般都会去改一下密码)</p></li></ul><h3 id="感悟和收获"><a href="#感悟和收获" class="headerlink" title="感悟和收获"></a>感悟和收获</h3><ul><li>因为一开始的没写数据加密，导致写完加密的方法上云后出现报错，导致我两三个小时都在debug，没研究出为什么，主要也是都是不知道为什么在阿里云那里看到数据库是全空的，反正清空了数据库就成了，让ximo含泪收下20.</li><li>还有跨域问题，之前试用期和hv是相同方法配置的，结果在这里却失败了，最后东试西试，在ximo的建议下，重新设置了cors的配置就成功了，但在这之前还搜到了nginx可以设置跨域，但在基本了解nginx后，发现运维还是实现不了跨域处理的，要处理还是得在后端方面。</li><li>也小小当了一把产品（资本家），稍微提了点可以完善的bug。<br><img src="https://github.com/Penryn/picture/blob/main/101.png?raw=true" alt="图片"><br><img src="https://github.com/Penryn/picture/blob/main/102.png?raw=true" alt="图片"><br><img src="https://github.com/Penryn/picture/blob/main/103.png?raw=true" alt="图片"><br><img src="https://github.com/Penryn/picture/blob/main/104.png?raw=true" alt="图片"></li></ul><p>总而言之，这一次还是组队寒软还是很愉快的！！！</p>]]></content>
      
      
      <categories>
          
          <category> 完整项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归</title>
      <link href="/2024/01/28/linear-regression/"/>
      <url>/2024/01/28/linear-regression/</url>
      
        <content type="html"><![CDATA[<p>在学习神经网络之前，我们先了解一些简单的基础知识，我们以线性回归（预测）和softmax回归（分类）为例，了解简单的神经网络架构，数据处理，制定损失函数和如何训练模型。</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>为了解释线性回归，我们举一个实际的例子：我们希望根据房屋的面积（平方米）和房龄（年）来估算房屋价格（元）。为了开发一个能预测房屋价格的模型，我们需要收集一个真实的数据集。这个数据集包括房屋价格、面积和房龄。在机器学习的术语中，该数据集称为训练数据集（training dataset）或训练集（training set）。每行数据（比如一次房屋交易相对应的数据）称为数据样本（sample），也可以称为数据点（data point）或数据实例（data instance）。我们把试图预测的目标（比如预测房屋价格）称为标签（label）或目标（target）。预测所依据的自变量（面积和房龄）称为特征（feature）或协变量（covariate）。</p><h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3><p>假设自变量x和因变量y之间的关系是线性的，即y可以表示x中的元素的加权和，这里通常允许包含一些噪声，在上图体现就是指目标（房屋价格）可以表示为特征（面积和房龄）的加权和，如下式：<br><img src="https://github.com/Penryn/picture/blob/main/10.jpg?raw=true" alt="图片"></p><p>W称为权重（weight），权重决定了每个特征对我们预测值的影响。b称为偏置（bias）、偏移量（offset）或截距（intercept）。偏置是指当所有特征都取值为0时，预测值应该为多少。即使现实中不会有任何房屋的面积是0或房龄正好是0年，我们仍然需要偏置项。如果没有偏置项，我们的模型的表达能力将受到限制。严格来说，式（3.1）是输入特征的一个仿射变换（affine transformation）。仿射变换的特点是通过加权和对特征进行线性变换（linear transformation），并通过偏置项进行平移（translation）。</p><p>给定一个数据集，我们的目标是寻找模型的权重w和偏置b，使得根据模型做出的预测大体符合数据中的真实价格。输出的预测值由输入特征通过线性模型的仿射变换确定，仿射变换由所选权重和偏置确定。</p><p>而在机器学习领域，我们通常使用的是高维数据集，建模时采用线性代数表示法会比较方便。这个过程中的求和将使用广播机制。给定训练数据特征X和对应的已知标签y，线性回归的目标是找到一组权重向量w和偏置b：当给定从X的同分布中抽样的新样本特征时，这组权重向量和偏置能够使新样本预测标签的误差尽可能小。</p><p>虽然我们确信给定x预测y的最佳模型是线性的，但我们很难找到一个理想的数据集。所以无论我们使用什么方式来观测征X和标签y，都可能会出现少量的观测误差。因此，即使确信特征与标签的潜在关系是呈线性的，我们也会加入一个噪声项以考虑观测误差带来的影响。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>我们要考虑模型拟合程度的度量，这时候就要考虑损失函数（loss function），他可以量化目标的实际值与预测值之间的差距。通常我们会选择非负数作为损失，且数值越小表示损失越小，完美预测时的损失为0。回归问题中最常用的损失函数是平方误差函数。<br><img src="https://github.com/Penryn/picture/blob/main/11.jpg?raw=true" alt="图片"><br>常数不会带来本质区别，但是形式上会更简单一些，对损失函数求导后常数系数为1</p><p>由于平方误差函数中的二次方项，估计值j(i)和观测值y(2)之较大的差距将导致更大的损失。为了度量模型在整个数据集上测质量，我们需计算在训练集n个样本上的损失均值（等价求和）<br><img src="https://github.com/Penryn/picture/blob/main/15.jpg?raw=true" alt="图片"></p><p>在训练模型时，我们希望寻找一组参数，这组参数能最小化在所有训练样本上的失，如下式<br><img src="https://github.com/Penryn/picture/blob/main/16.jpg?raw=true" alt="图片"></p><h3 id="更新模型"><a href="#更新模型" class="headerlink" title="更新模型"></a>更新模型</h3><p>为了寻找最佳的W和b，我们除了需要模型质量的度量方式，还要一种能够更新模型以提高模型预测质量的方法</p><h4 id="解析解"><a href="#解析解" class="headerlink" title="解析解"></a>解析解</h4><p>线性回归恰好是一个很简单的优化问题，它的解可以用一个式子简单表示，这类解叫做解析解。我们先将偏置b合并到参数w中，合并方法是在包含所有参数的矩阵中附加一列。我们的预测问题是最小化|y-Xw|的平方。这在损失平面上只有一个临界点，这个临界点对应于整个区域的损失极小值点。将损失关于w的导数设为0，得到解析解：<br><img src="https://github.com/Penryn/picture/blob/main/12.jpg?raw=true" alt="图片"></p><p>像线性回归这样的简单问题存在解析解，但并不是所有问题都存在解析解。解析解可以进行很好的数学分析，但解析解对问题的限制很严格，导致它无法广泛应用在深度学习中。</p><h4 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h4><p>即使在无法得到解析解的情况下，我们也可以有效地训练模型。在许多任务中，那些难以优化的模型效果会更好。</p><p>梯度下降的最简单的用法是计算损失函数（数据集中所有样本的损失均值）关于模型参数的导数（在这里也可以称为梯度）。但实际中的执行可能会非常慢，因为在每次更新参数之前，我们必须遍历整个数据集。因此，我们通常会在每次需要计算更新的时候随机抽取一小批样本，这种变体叫作小批量随机梯度下降（minibatch stochastic gradient descent）。</p><p>在每次迭代中，我们先随机抽取一个小批量B，它是由固定数量的训练样本组成的；然后，计算小批量的损失均值关于模型参数的导数（也可以称为梯度）；最后，将梯度乘以一个预先确定的正数η，并从当前参数的值中减掉。<br>我们用下面的数学公式来表示这一更新过程：<br><img src="https://github.com/Penryn/picture/blob/main/13.jpg?raw=true" alt="图片"></p><p>简单来说，该算法第一步是初始化模型的参数的值，如随机初始化，第二步是从数据集中随机抽取小批量样本且在负梯度方向更新参数，并不断迭代这一过程。对于平方损失和仿射变换，我们可以明确写成如下形式：<br><img src="https://github.com/Penryn/picture/blob/main/14.jpg?raw=true" alt="图片"></p><p>｜B｜表示每个小批量中的样本数，也称为批量大小（batch size）。η表示学习率（learning rate）。批量大小和学习率的值通常是预先手动指定，而不是通过模型训练得到的。这些可以调整但不在训练过程中更新的参数称为超参数（hyperparameter）。调参（hyperparametertuning）是选择超参数的过程。超参数通常是我们根据训练迭代结果来调整的，而训练迭代结果是在独立的验证数据集（validation dataset）上评估得到的。</p><p>在训练了预先确定的若干迭代次后（或者直到满足某些其他停止条件后），我们记录下模型参数的估计值，表示为w，b。但是，即使我们的函数确实是线性的且无噪声，这些估计值也不会使损失函数真正地达到最小值，因为算法会使损失向最小值缓慢收敛，但不能在有限的步数内非常精确地达到最小值。</p><p>线性回归恰好是一个在整个域中只有一个最小值的学习问题。但是对像深度神经网络这样复杂的模型来说，损失平面上通常包含多个最小值。深度学习实践者很少会花费大力气寻找这样一组参数，使在训练集上的损失达到最小值。事实上，更难做到的是找到一组参数，这组参数能够在我们从未见过的数据上实现较小的损失，这一挑战称为泛化（generalization）。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在基本了解线性回归模型后，我们可以尝试用代码的形式体现。</p><h4 id="从零开始实现"><a href="#从零开始实现" class="headerlink" title="从零开始实现"></a>从零开始实现</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import torch</span><br><span class="line"></span><br><span class="line"># 定义一个函数，它每次返回batch_size（批量大小）个随机样本的特征和标签</span><br><span class="line">def synthetic_data(w, b, num_examples):  #@save</span><br><span class="line">    """Generate y = Xw + b + noise."""</span><br><span class="line">    X = torch.normal(0, 1, (num_examples, len(w)))</span><br><span class="line"># 生成一个张量X，它的值来自均值为0，标准差为1的正态分布。张量的形状由num_examples和len(w)决定</span><br><span class="line">    y = torch.matmul(X, w) + b</span><br><span class="line">    y += torch.normal(0, 0.01, y.shape)</span><br><span class="line"># 给y添加一些噪声，噪声的值来自均值为0，标准差为0.01的正态分布</span><br><span class="line">    return X, y.reshape((-1, 1))</span><br><span class="line"># y被重塑为列向量。-1表示通过数据的形状和其他维度的值推断出该值</span><br><span class="line"></span><br><span class="line">def data_iter(batch_size, features, labels):  #@save</span><br><span class="line">    """Iterate through a dataset."""</span><br><span class="line">    num_examples = len(features)</span><br><span class="line">    indices = list(range(num_examples))</span><br><span class="line"># 将样本的索引存储在列表indices中</span><br><span class="line">    random.shuffle(indices)</span><br><span class="line"># 样本的读取顺序是随机的</span><br><span class="line">    for i in range(0, num_examples, batch_size):</span><br><span class="line"># 从0开始，每次以batch_size为步长递增，直到len(indices)</span><br><span class="line">        batch_indices = torch.tensor(indices[i:min(i + batch_size, num_examples)])</span><br><span class="line"># 最后一次可能不足一个批量</span><br><span class="line">    yield features[batch_indices], labels[batch_indices]</span><br><span class="line"></span><br><span class="line"># 定义了线性回归的矢量计算表达式</span><br><span class="line">def linreg(X, w, b):  #@save</span><br><span class="line">    """The linear regression model."""</span><br><span class="line">    return torch.matmul(X, w) + b</span><br><span class="line"></span><br><span class="line"># 定义了损失函数</span><br><span class="line"># 通过广播机制，y的形状转换为y_hat的形状</span><br><span class="line"># 除以2是为了抵消平方的导数，使得计算的梯度更简洁</span><br><span class="line">def squared_loss(y_hat, y):  #@save</span><br><span class="line">    """Squared loss."""</span><br><span class="line">    return (y_hat - y.reshape(y_hat.shape))**2 / 2</span><br><span class="line"></span><br><span class="line"># 定义了优化算法</span><br><span class="line">def sgd(params, lr, batch_size):  #@save</span><br><span class="line">    """Minibatch stochastic gradient descent."""</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        for param in params:</span><br><span class="line">            param -= lr * param.grad / batch_size</span><br><span class="line">            param.grad.zero_()</span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([2, -3.4])</span><br><span class="line">true_b = 4.2</span><br><span class="line"># 定义了真实的权重true_w和偏差true_b。我们将使用这些参数来生成我们的数据集</span><br><span class="line">features, labels = synthetic_data(true_w, true_b, 1000)</span><br><span class="line"># 调用synthetic_data函数生成1000个数据点的特征和标签</span><br><span class="line">print('features:', features[0],'\nlabel:', labels[0])</span><br><span class="line"></span><br><span class="line">batch_size = 10</span><br><span class="line"># 设置批次大小为10</span><br><span class="line">w = torch.normal(0, 0.01, size=(2, 1), requires_grad=True)</span><br><span class="line">b = torch.zeros(1, requires_grad=True)</span><br><span class="line"># 初始化权重w和偏差b。w的值来自均值为0，标准差为0.01的正态分布，b的值为0。</span><br><span class="line"># requires_grad=True表示w和b需要计算梯度，这对于后续的优化步骤是必要的</span><br><span class="line"># 通过requires_grad=True来告知系统需要记录与它们相关的计算，这样系统在反向传播过程中就会记录下与这些变量相关的梯度</span><br><span class="line"></span><br><span class="line"># 定义了小批量随机梯度下降优化器,它通过不断迭代模型参数来优化损失函数</span><br><span class="line"># 学习率</span><br><span class="line">lr = 0.03</span><br><span class="line"># 迭代周期数，即训练的次数</span><br><span class="line">num_epochs = 10</span><br><span class="line"># 网络模型</span><br><span class="line">net = linreg</span><br><span class="line"># 损失函数</span><br><span class="line">loss = squared_loss</span><br><span class="line">for epoch in range(num_epochs):</span><br><span class="line">    # 外层循环是对训练周期的迭代。每个训练周期(epoch)都会将整个数据集在神经网络中前向和后向传递一次</span><br><span class="line">    # 假设样本的数量可以除以批处理的大小，所有训练数据集中的示例在一个epoch中使用一次迭代。小批量例子的特征和标签分别用X和y表示</span><br><span class="line">    for X, y in data_iter(batch_size, features, labels):</span><br><span class="line">        # 内层循环是对数据批次的迭代。data_iter函数从特征和标签中生成大小为batch_size的批次。对于每个批次，X是特征，y是标签</span><br><span class="line">        l = loss(net(X, w, b), y)</span><br><span class="line">        # 通过首先将特征X通过当前权重w和偏差b的模型net，然后使用损失函数loss将输出与真实标签y进行比较，来计算当前批次的损失</span><br><span class="line">        l.sum().backward()</span><br><span class="line">        # 通过在损失张量上调用backward()来计算损失相对于模型参数的梯度。</span><br><span class="line">        # 在调用backward()之前使用sum()函数对批次的损失进行求和，因为PyTorch期望backward()的是标量值张量。</span><br><span class="line">        sgd([w, b], lr, batch_size)</span><br><span class="line">        # 使用计算出的梯度和随机梯度下降（SGD）优化器sgd更新模型参数。学习率lr和批次大小batch_size作为参数传递给优化器。</span><br><span class="line"># 由于我们之前设批量大小batch_size为10，每个小批量的损失l的形状为(10,)，而不是一个标量。</span><br><span class="line"># 因此，我们通过调用l.sum()将其归约为标量，从而调用backward得到标量的梯度。</span><br><span class="line"># 优化器实例sgd是一个函数，它将需要更新的参数作为输入，并在函数内部更新它们的值。</span><br><span class="line"># 由于参数w和b通过net函数被传递给优化器，所以优化器知道需要更新哪些参数</span><br><span class="line"># 在每个训练周期结束时，我们通过net(features)生成模型net的输出，并与标签labels进行比较。</span><br><span class="line"># 为了计算整个数据集上的模型的误差，我们计算所有预测值和真实标签之间的总损失，即l.sum()</span><br><span class="line"># 在每个训练周期结束时，我们通过net(features)生成模型net的输出，并与标签labels进行比较。</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        train_l = loss(net(features, w, b), labels)</span><br><span class="line">        print(f'epoch {epoch + 1}, loss {float(train_l.mean()):f}')</span><br><span class="line">    # 在每个训练周期结束后，计算并打印整个数据集的平均损失。使用torch.no_grad()</span><br><span class="line">    # 上下文管理器防止这些操作在计算图中被跟踪，因为我们不需要为这些操作计算梯度</span><br><span class="line">    # 在打印语句中的:f是浮点数的格式规范，它通过将损失格式化为十进制数，使损失更易于阅读</span><br><span class="line">    # train_l.mean()计算当前训练周期中整个数据集的平均损失。float()函数用于将损失（一个PyTorch张量）转换为Python浮点数。</span><br><span class="line">    # 由于我们用l.sum()对损失求和，所以train_l是一个形状为(1,)的张量。嵌套的mean()函数返回一个标量，即一个形状为()的张量。</span><br><span class="line">    # 由于train_l.mean()是一个标量，我们可以直接打印它而不是打印它的值</span><br><span class="line">print(f'error in estimating w: {true_w - w.reshape(true_w.shape)}')</span><br><span class="line">print(f'error in estimating b: {true_b - b}')</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="借助框架实现"><a href="#借助框架实现" class="headerlink" title="借助框架实现"></a>借助框架实现</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import torch</span><br><span class="line">from torch.utils import data</span><br><span class="line">from d2l import torch as d2l</span><br><span class="line">from torch import nn</span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([2, -3.4])</span><br><span class="line">true_b = 4.2</span><br><span class="line">features, labels = d2l.synthetic_data(true_w, true_b, 1000)</span><br><span class="line"></span><br><span class="line">def load_array(data_arrays, batch_size, is_train=True):</span><br><span class="line">    dataset = data.TensorDataset(*data_arrays)</span><br><span class="line">    return data.DataLoader(dataset, batch_size, shuffle=is_train)</span><br><span class="line">    # 通过TensorDataset和DataLoader类来实现数据的读取功能</span><br><span class="line">    # shuffle参数表示是否打乱数据集中的样本顺序</span><br><span class="line">batch_size = 10</span><br><span class="line">data_iter = load_array((features, labels), batch_size)</span><br><span class="line">next(iter(data_iter))</span><br><span class="line"># # 通过data_iter的next()函数来读取第一个小批量数据样本</span><br><span class="line"># # next()函数返回的每个样本都是一个形状为(10, 2)的小批量，其中的10是批量大小，2是每个样本的特征数</span><br><span class="line"></span><br><span class="line">net = nn.Sequential(nn.Linear(2, 1))</span><br><span class="line"># nn.Sequential类为串联在一起的多个层定义了一个容器</span><br><span class="line"># 当给定输入数据，nn.Sequential实例将数据传递给第一层，然后将第一层的输出作为第二层的输入，以此类推</span><br><span class="line"># 在我们的线性模型示例中，我们的模型只包含一个nn.Linear实例，我们将在后面的章节中继续介绍更复杂的例子</span><br><span class="line"># 我们将nn.Linear实例称为图层，它是一个包含权重和偏置的神经网络组件，它将输入映射到输出</span><br><span class="line"># 在PyTorch中，全连接层在其weight属性中存储权重，在其bias属性中存储偏置</span><br><span class="line"># 由于我们只想要对权重和偏置进行梯度下降，因此我们将其设置为requires_grad=True</span><br><span class="line">net[0].weight.data.normal_(0, 0.01)# w</span><br><span class="line">net[0].bias.data.fill_(0)# b</span><br><span class="line"># 初始化模型的权重和偏差。</span><br><span class="line"># 权重的值来自均值为0，标准差为0.01的正态分布，偏差的值为0。</span><br><span class="line">loss = nn.MSELoss()</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=0.03)</span><br><span class="line">num_epochs = 3</span><br><span class="line">for epoch in range(num_epochs):</span><br><span class="line">    for X, y in data_iter:</span><br><span class="line">        l = loss(net(X), y)</span><br><span class="line">        trainer.zero_grad()</span><br><span class="line">        l.backward()</span><br><span class="line">        trainer.step()</span><br><span class="line">    l = loss(net(features), labels)</span><br><span class="line">    # 在每个训练周期结束后，通过net(features)生成模型net的输出，并与标签labels进行比较，来计算整个数据集的损失。</span><br><span class="line">    print(f'epoch {epoch + 1}, loss {l:f}')</span><br><span class="line">w = net[0].weight.data</span><br><span class="line">print('error in estimating w', true_w - w.reshape(true_w.shape))</span><br><span class="line">b = net[0].bias.data</span><br><span class="line">print('error in estimating b', true_b - b)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>相信看到这里你应该对线性回归有简单的认识了。</p>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵与线性变换</title>
      <link href="/2024/01/24/linear-transformation/"/>
      <url>/2024/01/24/linear-transformation/</url>
      
        <content type="html"><![CDATA[<p>明明线代已经考完了，笔者现在才重新在几何理解线代，属实有点奇怪。<br>今天在b站的<a href="https://space.bilibili.com/88461692">3Blue1Brown</a>听他的线性代数本质，清晰了许多。</p><p><strong>很遗憾，矩阵是什么是说不清的，你必须得自己看看。——墨菲斯</strong></p><h3 id="矩阵与向量相乘"><a href="#矩阵与向量相乘" class="headerlink" title="矩阵与向量相乘"></a>矩阵与向量相乘</h3><p>首先，我们可以知道，直角坐标系中，任意一个向量可以用两个最基本的正交基向量表示，而将两个向量变换（不改变原点位置，直线仍然是直线，对应平行线依旧平行）后的位置，他们坐标会发生变化，相应的，他们所构成的向量也会发生变化。</p><p>事实上，我们想要知道变换后的向量的坐标，我们只需要变换后的基向量的坐标和他们之间的几何关系就可以求得。</p><p>而变化后的基向量的坐标（3，-2）（2，1）组成一个矩阵，而原线性关系为（5，7），具体可看下面的图片<br><img src="https://github.com/Penryn/picture/blob/main/1.png?raw=true" alt="图片"><br><img src="https://github.com/Penryn/picture/blob/main/3.png?raw=true" alt="图片"></p><p>将其抽象出来，我们可以得到矩阵乘于向量的几何含义，就是通过这样的运算得到所构成向量的新坐标。<br><img src="https://github.com/Penryn/picture/blob/main/4.png?raw=true" alt="图片"></p><h3 id="矩阵矩阵相乘"><a href="#矩阵矩阵相乘" class="headerlink" title="矩阵矩阵相乘"></a>矩阵矩阵相乘</h3><p>在了解过上面矩阵与向量相乘的几何意义后，我们可以进一步理解矩阵与矩阵相乘的几何意义<br>在矩阵与矩阵相乘时，我们是要从右边的矩阵看到左边的矩阵，右边的矩阵可以看作若干个向量所构成的矩阵，然后这个向量以左边矩阵的变化。即相当于原来最初的基向量先变成右边矩阵的形式，在分别每列进行左边矩阵的变换。<br><img src="https://github.com/Penryn/picture/blob/main/5.png?raw=true" alt="图片"><br><img src="https://github.com/Penryn/picture/blob/main/6.png?raw=true" alt="图片">  </p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gorm的多种关联方式</title>
      <link href="/2023/11/23/gorm-association/"/>
      <url>/2023/11/23/gorm-association/</url>
      
        <content type="html"><![CDATA[<p><a href="https://gorm.io/zh_CN/docs/belongs_to.html">Gorm官网</a>上将这个分成了belongs to，has one，has many，many to many这些关系，今天笔者就简单分成这三种关系（一对一，一对多和多对多）来逐一讲解。</p><hr><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>以笔者写的一份项目为例（一个用户对应一个用户信息）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package models</span><br><span class="line"></span><br><span class="line">type User struct {</span><br><span class="line">UserID     int      `json:"-" gorm:"primaryKey"`</span><br><span class="line">Name       string   `json:"name"`</span><br><span class="line">Password   []byte   `json:"-"`</span><br><span class="line">Userinfo   Userinfo `json:"-"`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Userinfo struct {</span><br><span class="line">ID       int    `json:"-" `</span><br><span class="line">UserID   int    `json:"-"`</span><br><span class="line">Name     string `json:"name"`</span><br><span class="line">Phone    string `json:"phone"`</span><br><span class="line">Email    string `json:"email"`</span><br><span class="line">Birthday string `json:"birthday"`</span><br><span class="line">Address  string `json:"address"`</span><br><span class="line">Motto    string `json:"motto"`</span><br><span class="line">Avatar   string `json:"avatar"`</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>增</li></ol><ul><li><p>创建用户并携带相关个人信息</p></li><li><p>新建用户并关联已有信息</p></li><li><p>新建个人信息并关联已有用户</p></li><li><p>已有用户关联已有信息</p></li></ul><ol start="2"><li>删</li></ol><ul><li><p>清除用户与信息的关系</p></li><li><p>删除用户并连带信息一起删除</p></li><li><p>仅删除信息保留用户</p></li><li><p>仅删除用户保留信息</p></li></ul><ol start="3"><li>改</li></ol><ul><li><p>直接通过信息表修改内容</p></li><li><p>通过用户表修改内容</p></li></ul><ol start="4"><li>查</li></ol><p>（等笔者找个时间补上）</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你搭建属于你自己的hexo博客，并布置在github page上</title>
      <link href="/2023/11/11/createblog/"/>
      <url>/2023/11/11/createblog/</url>
      
        <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><hr><h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h2><ul><li>Node.js</li><li>Git</li><li>修改npm为淘宝镜像源，并设置cnpm</li></ul><ol><li><p>环境的下载只需点开网站找到适合自己的版本安装即可，这里不赘述。</p></li><li><p>安装完毕后可以通过cmd命令行输入node -v,npm -v和git –version来验证，如果出现下图则安装成功。<br>  <img src="/../picture/createblog/1.png" alt="图片"></p></li><li><p>修改npm的镜像源为在国内更为稳定的淘宝镜像源（建议永久设置）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">临时改变镜像源 </span><br><span class="line">npm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">永久设置为淘宝镜像源</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">cnpm安装，在国外服务器不佳时就可以用cnpm代替npm命令</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></tbody></table></figure></li></ol><hr><h2 id="2-github准备"><a href="#2-github准备" class="headerlink" title="2.github准备"></a>2.github准备</h2><ol><li><p>打开<a href="https://github.com/">github</a>,并登录或注册你的账号</p></li><li><p>新建一个格式为你的用户名.github.io的仓库，并设置为公开<br> <img src="/../picture/createblog/2.png" alt="图片"><br> <img src="/../picture/createblog/3.png" alt="图片"></p></li><li><p>创建成功后在桌面点击右键，Git Bash Here，打开Git的命令行输入这两行代码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "此处填写你注册github时的用户名"</span><br><span class="line">git config --global user.email "此处填写你注册github时的邮箱"</span><br></pre></td></tr></tbody></table></figure></li><li><p>然后就可以在C:/Users/[电脑登录的用户名]/下找到.gitconfig文件（如果没能找到，请打开显示windows显示隐藏文件的功能），用编辑器打开看到以下内容代表配置成功。<br><img src="/../picture/createblog/5.png" alt="图片"></p></li></ol><hr><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><ol><li>首先新建一个文件夹👀作为你的博客文件的存放位置，点进去打开Git命令行分别输入<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># hexo框架的安装</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">&nbsp; </span><br><span class="line"># 等上一个命令完成后，再输入下面的命令</span><br><span class="line">hexo init</span><br><span class="line">&nbsp; &nbsp; </span><br><span class="line"># 安装博客所需要的依赖文件(如果上面安装了cnpm则可以把下面的npm换成cnpm)</span><br><span class="line">npm install</span><br></pre></td></tr></tbody></table></figure></li><li>等待运行完成，你会发现此时文件夹内多了好多文件。此时本地搭建完成，我们来运行一下试试看，输入以下命令.<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g           </span><br><span class="line">hexo s                                          </span><br></pre></td></tr></tbody></table></figure><img src="/../picture/createblog/4.png" alt="图片"></li><li>根据提示我们打开 <a href="http://localhost:4000/">http://localhost:4000</a> ，就可以看到生成的网页，说明Hexo已经成功在本地运行.</li></ol><hr><h2 id="4-发布到github"><a href="#4-发布到github" class="headerlink" title="4.发布到github"></a>4.发布到github</h2><p>我们已经完成了Hexo下载安装和本地运行，接下来将本地博客发布到Github让别人也能通过网址访问你的博客。</p><ol><li><p>在博客所在文件夹下打开Git命令行，分别输入以下命令(如果上面安装了cnpm则可以把下面的npm换成cnpm)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装用来发布的插件</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">&nbsp;​</span><br><span class="line"># 将本地目录与Github关联起来</span><br><span class="line"># 这步输入后一直回车即可</span><br><span class="line">ssh-keygen -t rsa -C "你的邮箱地址"</span><br></pre></td></tr></tbody></table></figure></li><li><p>在 C:/Users/[电脑登录的用户名] 目录下找到名为.ssh 的文件夹，打开其中的 id_rsa.pub，复制里面的的内容。 然后打开 Github，点击右上角的头像 Settings 选择 SSH and GPG keys。<br><img src="/../picture/createblog/6.png" alt="图片"><br><img src="/../picture/createblog/7.png" alt="图片"></p></li><li><p>点击 New SSH key 将之前复制的内容粘帖到 Key 的框中，Title 可以随意，点击 Add SSH key 完成添加<br><img src="/../picture/createblog/8.png" alt="图片"></p></li><li><p>回到命令行界面测试是否与Github连接成功，输入ssh -T <a href="mailto:git@github.com">git@github.com</a>，出现一个询问内容输入yes，出现You’ve successfully …说明连接成功。</p></li><li><p>进入博客站点目录，用文本编辑器打开_config.yml，这个_config.yml 是博客的配置文件，在以后会经常使用到，修改如下图的几个地方：<br><img src="/../picture/createblog/9.png" alt="图片"></p></li><li><p>然后滑到文件最底部deploy处添加如下代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&nbsp; type: git</span><br><span class="line">&nbsp; repo: git@github.com:github用户名/github用户名.github.io.git &nbsp;        </span><br><span class="line">&nbsp; branch: master     (或者是main)</span><br></pre></td></tr></tbody></table></figure></li></ol><p>7.最后一步，生成页面并发布，我们执行如下命令</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&nbsp; # generate, Hexo会根据配置文件渲染出一套静态页面</span><br><span class="line">&nbsp; hexo g</span><br><span class="line">&nbsp;​</span><br><span class="line">&nbsp; # deploy, 将上一步渲染出的一系列文件上传至至Github Pages</span><br><span class="line">&nbsp; hexo d</span><br><span class="line">&nbsp;​</span><br><span class="line">&nbsp; # 或者也可以直接输入此命令，直接完成渲染和上传</span><br><span class="line">&nbsp; hexo g -d</span><br></pre></td></tr></tbody></table></figure><p>上传完成后，在浏览器中打开网址 你的github用户名.github.io，查看上传的网页。如果页面变成了之前本地调试时的样子，说明上传完成了。没变的话查看一下上传时命令行窗口的信息有没有错误信息，没有的话等一下或按ctrl+f5刷新清除一下浏览器缓存试试。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
